/*
Stacks Blockchain API

Welcome to the API reference overview for the [Stacks Blockchain API](https://docs.hiro.so/stacks-blockchain-api).        [Download Postman collection](https://hirosystems.github.io/stacks-blockchain-api/collection.json)

API version: v8.1.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package stacks_blockchain_api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TransactionsAPIService TransactionsAPI service
type TransactionsAPIService service

type ApiGetAddressMempoolTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	principal GetFilteredEventsAddressParameter
	limit *int32
	offset *int32
	unanchored *bool
}

// Results per page
func (r ApiGetAddressMempoolTransactionsRequest) Limit(limit int32) ApiGetAddressMempoolTransactionsRequest {
	r.limit = &limit
	return r
}

// Result offset
func (r ApiGetAddressMempoolTransactionsRequest) Offset(offset int32) ApiGetAddressMempoolTransactionsRequest {
	r.offset = &offset
	return r
}

// Include data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetAddressMempoolTransactionsRequest) Unanchored(unanchored bool) ApiGetAddressMempoolTransactionsRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetAddressMempoolTransactionsRequest) Execute() (*GetMempoolTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetAddressMempoolTransactionsExecute(r)
}

/*
GetAddressMempoolTransactions Transactions for address

Retrieves all transactions for a given address that are currently in mempool

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param principal
 @return ApiGetAddressMempoolTransactionsRequest
*/
func (a *TransactionsAPIService) GetAddressMempoolTransactions(ctx context.Context, principal GetFilteredEventsAddressParameter) ApiGetAddressMempoolTransactionsRequest {
	return ApiGetAddressMempoolTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		principal: principal,
	}
}

// Execute executes the request
//  @return GetMempoolTransactionList200Response
func (a *TransactionsAPIService) GetAddressMempoolTransactionsExecute(r ApiGetAddressMempoolTransactionsRequest) (*GetMempoolTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMempoolTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetAddressMempoolTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/address/{principal}/mempool"
	localVarPath = strings.Replace(localVarPath, "{"+"principal"+"}", url.PathEscape(parameterValueToString(r.principal, "principal")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.unanchored != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unanchored", r.unanchored, "form", "")
	} else {
		var defaultValue bool = false
		r.unanchored = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddressTransactionEventsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	address GetFilteredEventsAddressParameter
	txId string
	limit *int32
	offset *int32
}

// Results per page
func (r ApiGetAddressTransactionEventsRequest) Limit(limit int32) ApiGetAddressTransactionEventsRequest {
	r.limit = &limit
	return r
}

// Result offset
func (r ApiGetAddressTransactionEventsRequest) Offset(offset int32) ApiGetAddressTransactionEventsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetAddressTransactionEventsRequest) Execute() (*GetAddressTransactionEvents200Response, *http.Response, error) {
	return r.ApiService.GetAddressTransactionEventsExecute(r)
}

/*
GetAddressTransactionEvents Get events for an address transaction

Retrieves a paginated list of all STX, FT and NFT events concerning a STX address or Smart Contract ID within a specific transaction.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param address
 @param txId Transaction ID
 @return ApiGetAddressTransactionEventsRequest
*/
func (a *TransactionsAPIService) GetAddressTransactionEvents(ctx context.Context, address GetFilteredEventsAddressParameter, txId string) ApiGetAddressTransactionEventsRequest {
	return ApiGetAddressTransactionEventsRequest{
		ApiService: a,
		ctx: ctx,
		address: address,
		txId: txId,
	}
}

// Execute executes the request
//  @return GetAddressTransactionEvents200Response
func (a *TransactionsAPIService) GetAddressTransactionEventsExecute(r ApiGetAddressTransactionEventsRequest) (*GetAddressTransactionEvents200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAddressTransactionEvents200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetAddressTransactionEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v2/addresses/{address}/transactions/{tx_id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", url.PathEscape(parameterValueToString(r.address, "address")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tx_id"+"}", url.PathEscape(parameterValueToString(r.txId, "txId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAddressTransactionsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	address GetFilteredEventsAddressParameter
	limit *int32
	offset *int32
}

// Results per page
func (r ApiGetAddressTransactionsRequest) Limit(limit int32) ApiGetAddressTransactionsRequest {
	r.limit = &limit
	return r
}

// Result offset
func (r ApiGetAddressTransactionsRequest) Offset(offset int32) ApiGetAddressTransactionsRequest {
	r.offset = &offset
	return r
}

func (r ApiGetAddressTransactionsRequest) Execute() (*GetAddressTransactions200Response, *http.Response, error) {
	return r.ApiService.GetAddressTransactionsExecute(r)
}

/*
GetAddressTransactions Get address transactions

Retrieves a paginated list of confirmed transactions sent or received by a STX address or Smart Contract ID, alongside the total amount of STX sent or received and the number of STX, FT and NFT transfers contained within each transaction.
        
        More information on Transaction types can be found [here](https://docs.stacks.co/understand-stacks/transactions#types).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param address
 @return ApiGetAddressTransactionsRequest
*/
func (a *TransactionsAPIService) GetAddressTransactions(ctx context.Context, address GetFilteredEventsAddressParameter) ApiGetAddressTransactionsRequest {
	return ApiGetAddressTransactionsRequest{
		ApiService: a,
		ctx: ctx,
		address: address,
	}
}

// Execute executes the request
//  @return GetAddressTransactions200Response
func (a *TransactionsAPIService) GetAddressTransactionsExecute(r ApiGetAddressTransactionsRequest) (*GetAddressTransactions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAddressTransactions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetAddressTransactions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v2/addresses/{address}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", url.PathEscape(parameterValueToString(r.address, "address")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDroppedMempoolTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	offset *int32
	limit *int32
}

// Result offset
func (r ApiGetDroppedMempoolTransactionListRequest) Offset(offset int32) ApiGetDroppedMempoolTransactionListRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetDroppedMempoolTransactionListRequest) Limit(limit int32) ApiGetDroppedMempoolTransactionListRequest {
	r.limit = &limit
	return r
}

func (r ApiGetDroppedMempoolTransactionListRequest) Execute() (*GetDroppedMempoolTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetDroppedMempoolTransactionListExecute(r)
}

/*
GetDroppedMempoolTransactionList Get dropped mempool transactions

Retrieves all recently-broadcast transactions that have been dropped from the mempool.

        Transactions are dropped from the mempool if:
         * they were stale and awaiting garbage collection or,
         * were expensive, or
         * were replaced with a new fee

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDroppedMempoolTransactionListRequest
*/
func (a *TransactionsAPIService) GetDroppedMempoolTransactionList(ctx context.Context) ApiGetDroppedMempoolTransactionListRequest {
	return ApiGetDroppedMempoolTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDroppedMempoolTransactionList200Response
func (a *TransactionsAPIService) GetDroppedMempoolTransactionListExecute(r ApiGetDroppedMempoolTransactionListRequest) (*GetDroppedMempoolTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDroppedMempoolTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetDroppedMempoolTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/mempool/dropped"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFilteredEventsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	txId *string
	address *GetFilteredEventsAddressParameter
	type_ *[]GetFilteredEventsTypeParameterInner
	offset *int32
	limit *int32
}

// Transaction ID
func (r ApiGetFilteredEventsRequest) TxId(txId string) ApiGetFilteredEventsRequest {
	r.txId = &txId
	return r
}

func (r ApiGetFilteredEventsRequest) Address(address GetFilteredEventsAddressParameter) ApiGetFilteredEventsRequest {
	r.address = &address
	return r
}

func (r ApiGetFilteredEventsRequest) Type_(type_ []GetFilteredEventsTypeParameterInner) ApiGetFilteredEventsRequest {
	r.type_ = &type_
	return r
}

// Result offset
func (r ApiGetFilteredEventsRequest) Offset(offset int32) ApiGetFilteredEventsRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetFilteredEventsRequest) Limit(limit int32) ApiGetFilteredEventsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetFilteredEventsRequest) Execute() (*ListOfEvents, *http.Response, error) {
	return r.ApiService.GetFilteredEventsExecute(r)
}

/*
GetFilteredEvents Transaction Events

Retrieves the list of events filtered by principal (STX address or Smart Contract ID), transaction id or event types.
        The list of event types is ('smart_contract_log', 'stx_lock', 'stx_asset', 'fungible_token_asset', 'non_fungible_token_asset').

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFilteredEventsRequest
*/
func (a *TransactionsAPIService) GetFilteredEvents(ctx context.Context) ApiGetFilteredEventsRequest {
	return ApiGetFilteredEventsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOfEvents
func (a *TransactionsAPIService) GetFilteredEventsExecute(r ApiGetFilteredEventsRequest) (*ListOfEvents, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOfEvents
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetFilteredEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.txId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_id", r.txId, "form", "")
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMempoolTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	senderAddress *string
	recipientAddress *string
	address *string
	orderBy *OrderBy
	order *Order
	unanchored *bool
	offset *int32
	limit *int32
}

// STX Address
func (r ApiGetMempoolTransactionListRequest) SenderAddress(senderAddress string) ApiGetMempoolTransactionListRequest {
	r.senderAddress = &senderAddress
	return r
}

// STX Address
func (r ApiGetMempoolTransactionListRequest) RecipientAddress(recipientAddress string) ApiGetMempoolTransactionListRequest {
	r.recipientAddress = &recipientAddress
	return r
}

// STX Address
func (r ApiGetMempoolTransactionListRequest) Address(address string) ApiGetMempoolTransactionListRequest {
	r.address = &address
	return r
}

// Option to sort results by transaction age, size, or fee rate.
func (r ApiGetMempoolTransactionListRequest) OrderBy(orderBy OrderBy) ApiGetMempoolTransactionListRequest {
	r.orderBy = &orderBy
	return r
}

// Results order
func (r ApiGetMempoolTransactionListRequest) Order(order Order) ApiGetMempoolTransactionListRequest {
	r.order = &order
	return r
}

// Include data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetMempoolTransactionListRequest) Unanchored(unanchored bool) ApiGetMempoolTransactionListRequest {
	r.unanchored = &unanchored
	return r
}

// Result offset
func (r ApiGetMempoolTransactionListRequest) Offset(offset int32) ApiGetMempoolTransactionListRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetMempoolTransactionListRequest) Limit(limit int32) ApiGetMempoolTransactionListRequest {
	r.limit = &limit
	return r
}

func (r ApiGetMempoolTransactionListRequest) Execute() (*GetMempoolTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetMempoolTransactionListExecute(r)
}

/*
GetMempoolTransactionList Get mempool transactions

Retrieves all transactions that have been recently broadcast to the mempool. These are pending transactions awaiting confirmation.

        If you need to monitor new transactions, we highly recommend subscribing to [WebSockets or Socket.io](https://github.com/hirosystems/stacks-blockchain-api/tree/master/client) for real-time updates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMempoolTransactionListRequest
*/
func (a *TransactionsAPIService) GetMempoolTransactionList(ctx context.Context) ApiGetMempoolTransactionListRequest {
	return ApiGetMempoolTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMempoolTransactionList200Response
func (a *TransactionsAPIService) GetMempoolTransactionListExecute(r ApiGetMempoolTransactionListRequest) (*GetMempoolTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMempoolTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetMempoolTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/mempool"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.senderAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sender_address", r.senderAddress, "form", "")
	}
	if r.recipientAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recipient_address", r.recipientAddress, "form", "")
	}
	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.unanchored != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unanchored", r.unanchored, "form", "")
	} else {
		var defaultValue bool = false
		r.unanchored = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMempoolTransactionStatsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
}

func (r ApiGetMempoolTransactionStatsRequest) Execute() (*MempoolTransactionStatsResponse, *http.Response, error) {
	return r.ApiService.GetMempoolTransactionStatsExecute(r)
}

/*
GetMempoolTransactionStats Get statistics for mempool transactions

Queries for transactions counts, age (by block height), fees (simple average), and size.
        All results broken down by transaction type and percentiles (p25, p50, p75, p95).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMempoolTransactionStatsRequest
*/
func (a *TransactionsAPIService) GetMempoolTransactionStats(ctx context.Context) ApiGetMempoolTransactionStatsRequest {
	return ApiGetMempoolTransactionStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MempoolTransactionStatsResponse
func (a *TransactionsAPIService) GetMempoolTransactionStatsExecute(r ApiGetMempoolTransactionStatsRequest) (*MempoolTransactionStatsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MempoolTransactionStatsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetMempoolTransactionStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/mempool/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRawTransactionByIdRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	txId string
	eventLimit *int32
	eventOffset *int32
}

// Results per page
func (r ApiGetRawTransactionByIdRequest) EventLimit(eventLimit int32) ApiGetRawTransactionByIdRequest {
	r.eventLimit = &eventLimit
	return r
}

// Result offset
func (r ApiGetRawTransactionByIdRequest) EventOffset(eventOffset int32) ApiGetRawTransactionByIdRequest {
	r.eventOffset = &eventOffset
	return r
}

func (r ApiGetRawTransactionByIdRequest) Execute() (*GetRawTransactionResult, *http.Response, error) {
	return r.ApiService.GetRawTransactionByIdExecute(r)
}

/*
GetRawTransactionById Get raw transaction

Retrieves a hex encoded serialized transaction for a given ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txId Transaction ID
 @return ApiGetRawTransactionByIdRequest
*/
func (a *TransactionsAPIService) GetRawTransactionById(ctx context.Context, txId string) ApiGetRawTransactionByIdRequest {
	return ApiGetRawTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
		txId: txId,
	}
}

// Execute executes the request
//  @return GetRawTransactionResult
func (a *TransactionsAPIService) GetRawTransactionByIdExecute(r ApiGetRawTransactionByIdRequest) (*GetRawTransactionResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRawTransactionResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetRawTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/{tx_id}/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"tx_id"+"}", url.PathEscape(parameterValueToString(r.txId, "txId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_limit", r.eventLimit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.eventLimit = &defaultValue
	}
	if r.eventOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_offset", r.eventOffset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.eventOffset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionByIdRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	txId string
	eventLimit *int32
	eventOffset *int32
	unanchored *bool
}

// Results per page
func (r ApiGetTransactionByIdRequest) EventLimit(eventLimit int32) ApiGetTransactionByIdRequest {
	r.eventLimit = &eventLimit
	return r
}

// Result offset
func (r ApiGetTransactionByIdRequest) EventOffset(eventOffset int32) ApiGetTransactionByIdRequest {
	r.eventOffset = &eventOffset
	return r
}

// Include data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTransactionByIdRequest) Unanchored(unanchored bool) ApiGetTransactionByIdRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTransactionByIdRequest) Execute() (*GetTransactionById200Response, *http.Response, error) {
	return r.ApiService.GetTransactionByIdExecute(r)
}

/*
GetTransactionById Get transaction

Retrieves transaction details for a given transaction ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param txId Transaction ID
 @return ApiGetTransactionByIdRequest
*/
func (a *TransactionsAPIService) GetTransactionById(ctx context.Context, txId string) ApiGetTransactionByIdRequest {
	return ApiGetTransactionByIdRequest{
		ApiService: a,
		ctx: ctx,
		txId: txId,
	}
}

// Execute executes the request
//  @return GetTransactionById200Response
func (a *TransactionsAPIService) GetTransactionByIdExecute(r ApiGetTransactionByIdRequest) (*GetTransactionById200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionById200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactionById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/{tx_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tx_id"+"}", url.PathEscape(parameterValueToString(r.txId, "txId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.eventLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_limit", r.eventLimit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.eventLimit = &defaultValue
	}
	if r.eventOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_offset", r.eventOffset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.eventOffset = &defaultValue
	}
	if r.unanchored != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unanchored", r.unanchored, "form", "")
	} else {
		var defaultValue bool = false
		r.unanchored = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionListRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	offset *int32
	limit *int32
	type_ *[]GetTransactionListTypeParameterInner
	unanchored *bool
	order *GetTransactionListOrderParameter
	sortBy *GetTransactionListSortByParameter
	fromAddress *string
	toAddress *string
	startTime *int32
	endTime *int32
	contractId *string
	functionName *string
	nonce *int32
}

// Result offset
func (r ApiGetTransactionListRequest) Offset(offset int32) ApiGetTransactionListRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetTransactionListRequest) Limit(limit int32) ApiGetTransactionListRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionListRequest) Type_(type_ []GetTransactionListTypeParameterInner) ApiGetTransactionListRequest {
	r.type_ = &type_
	return r
}

// Include data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTransactionListRequest) Unanchored(unanchored bool) ApiGetTransactionListRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTransactionListRequest) Order(order GetTransactionListOrderParameter) ApiGetTransactionListRequest {
	r.order = &order
	return r
}

// Option to sort results by block height, timestamp, or fee
func (r ApiGetTransactionListRequest) SortBy(sortBy GetTransactionListSortByParameter) ApiGetTransactionListRequest {
	r.sortBy = &sortBy
	return r
}

// Option to filter results by sender address
func (r ApiGetTransactionListRequest) FromAddress(fromAddress string) ApiGetTransactionListRequest {
	r.fromAddress = &fromAddress
	return r
}

// Option to filter results by recipient address
func (r ApiGetTransactionListRequest) ToAddress(toAddress string) ApiGetTransactionListRequest {
	r.toAddress = &toAddress
	return r
}

// Filter by transactions after this timestamp (unix timestamp in seconds)
func (r ApiGetTransactionListRequest) StartTime(startTime int32) ApiGetTransactionListRequest {
	r.startTime = &startTime
	return r
}

// Filter by transactions before this timestamp (unix timestamp in seconds)
func (r ApiGetTransactionListRequest) EndTime(endTime int32) ApiGetTransactionListRequest {
	r.endTime = &endTime
	return r
}

// Option to filter results by contract ID
func (r ApiGetTransactionListRequest) ContractId(contractId string) ApiGetTransactionListRequest {
	r.contractId = &contractId
	return r
}

// Filter by contract call transactions involving this function name
func (r ApiGetTransactionListRequest) FunctionName(functionName string) ApiGetTransactionListRequest {
	r.functionName = &functionName
	return r
}

// Filter by transactions with this nonce
func (r ApiGetTransactionListRequest) Nonce(nonce int32) ApiGetTransactionListRequest {
	r.nonce = &nonce
	return r
}

func (r ApiGetTransactionListRequest) Execute() (*GetTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetTransactionListExecute(r)
}

/*
GetTransactionList Get recent transactions

Retrieves all recently mined transactions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTransactionListRequest
*/
func (a *TransactionsAPIService) GetTransactionList(ctx context.Context) ApiGetTransactionListRequest {
	return ApiGetTransactionListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetTransactionList200Response
func (a *TransactionsAPIService) GetTransactionListExecute(r ApiGetTransactionListRequest) (*GetTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactionList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "form", "multi")
		}
	}
	if r.unanchored != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unanchored", r.unanchored, "form", "")
	} else {
		var defaultValue bool = false
		r.unanchored = &defaultValue
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	} else {
		var defaultValue GetTransactionListSortByParameter = GetTransactionListSortByParameter{String: &[]string{"block_height"}[0]}
		r.sortBy = &defaultValue
	}
	if r.fromAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_address", r.fromAddress, "form", "")
	}
	if r.toAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to_address", r.toAddress, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.contractId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "contract_id", r.contractId, "form", "")
	}
	if r.functionName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "function_name", r.functionName, "form", "")
	}
	if r.nonce != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nonce", r.nonce, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsByBlockRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	heightOrHash GetBlockHeightOrHashParameter
	limit *int32
	offset *int32
}

// Results per page
func (r ApiGetTransactionsByBlockRequest) Limit(limit int32) ApiGetTransactionsByBlockRequest {
	r.limit = &limit
	return r
}

// Result offset
func (r ApiGetTransactionsByBlockRequest) Offset(offset int32) ApiGetTransactionsByBlockRequest {
	r.offset = &offset
	return r
}

func (r ApiGetTransactionsByBlockRequest) Execute() (*GetTransactionsByBlock200Response, *http.Response, error) {
	return r.ApiService.GetTransactionsByBlockExecute(r)
}

/*
GetTransactionsByBlock Get transactions by block

Retrieves transactions confirmed in a single block

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heightOrHash
 @return ApiGetTransactionsByBlockRequest
*/
func (a *TransactionsAPIService) GetTransactionsByBlock(ctx context.Context, heightOrHash GetBlockHeightOrHashParameter) ApiGetTransactionsByBlockRequest {
	return ApiGetTransactionsByBlockRequest{
		ApiService: a,
		ctx: ctx,
		heightOrHash: heightOrHash,
	}
}

// Execute executes the request
//  @return GetTransactionsByBlock200Response
func (a *TransactionsAPIService) GetTransactionsByBlockExecute(r ApiGetTransactionsByBlockRequest) (*GetTransactionsByBlock200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionsByBlock200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactionsByBlock")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v2/blocks/{height_or_hash}/transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"height_or_hash"+"}", url.PathEscape(parameterValueToString(r.heightOrHash, "heightOrHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsByBlockHashRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	blockHash string
	offset *int32
	limit *int32
}

// Result offset
func (r ApiGetTransactionsByBlockHashRequest) Offset(offset int32) ApiGetTransactionsByBlockHashRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetTransactionsByBlockHashRequest) Limit(limit int32) ApiGetTransactionsByBlockHashRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionsByBlockHashRequest) Execute() (*GetTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetTransactionsByBlockHashExecute(r)
}

/*
GetTransactionsByBlockHash Transactions by block hash

**NOTE:** This endpoint is deprecated in favor of [Get transactions by block](/api/get-transactions-by-block).

        Retrieves a list of all transactions within a block for a given block hash.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockHash
 @return ApiGetTransactionsByBlockHashRequest

Deprecated
*/
func (a *TransactionsAPIService) GetTransactionsByBlockHash(ctx context.Context, blockHash string) ApiGetTransactionsByBlockHashRequest {
	return ApiGetTransactionsByBlockHashRequest{
		ApiService: a,
		ctx: ctx,
		blockHash: blockHash,
	}
}

// Execute executes the request
//  @return GetTransactionList200Response
// Deprecated
func (a *TransactionsAPIService) GetTransactionsByBlockHashExecute(r ApiGetTransactionsByBlockHashRequest) (*GetTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactionsByBlockHash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/block/{block_hash}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_hash"+"}", url.PathEscape(parameterValueToString(r.blockHash, "blockHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionsByBlockHeightRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	height int32
	offset *int32
	limit *int32
}

// Result offset
func (r ApiGetTransactionsByBlockHeightRequest) Offset(offset int32) ApiGetTransactionsByBlockHeightRequest {
	r.offset = &offset
	return r
}

// Results per page
func (r ApiGetTransactionsByBlockHeightRequest) Limit(limit int32) ApiGetTransactionsByBlockHeightRequest {
	r.limit = &limit
	return r
}

func (r ApiGetTransactionsByBlockHeightRequest) Execute() (*GetTransactionList200Response, *http.Response, error) {
	return r.ApiService.GetTransactionsByBlockHeightExecute(r)
}

/*
GetTransactionsByBlockHeight Transactions by block height

**NOTE:** This endpoint is deprecated in favor of [Get transactions by block](/api/get-transactions-by-block).

        Retrieves all transactions within a block at a given height

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param height Block height
 @return ApiGetTransactionsByBlockHeightRequest

Deprecated
*/
func (a *TransactionsAPIService) GetTransactionsByBlockHeight(ctx context.Context, height int32) ApiGetTransactionsByBlockHeightRequest {
	return ApiGetTransactionsByBlockHeightRequest{
		ApiService: a,
		ctx: ctx,
		height: height,
	}
}

// Execute executes the request
//  @return GetTransactionList200Response
// Deprecated
func (a *TransactionsAPIService) GetTransactionsByBlockHeightExecute(r ApiGetTransactionsByBlockHeightRequest) (*GetTransactionList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetTransactionList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTransactionsByBlockHeight")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/block_height/{height}"
	localVarPath = strings.Replace(localVarPath, "{"+"height"+"}", url.PathEscape(parameterValueToString(r.height, "height")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.height < 0 {
		return localVarReturnValue, nil, reportError("height must be greater than 0")
	}

	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTxListDetailsRequest struct {
	ctx context.Context
	ApiService *TransactionsAPIService
	txId *[]string
	eventLimit *int32
	eventOffset *int32
	unanchored *bool
}

func (r ApiGetTxListDetailsRequest) TxId(txId []string) ApiGetTxListDetailsRequest {
	r.txId = &txId
	return r
}

// Results per page
func (r ApiGetTxListDetailsRequest) EventLimit(eventLimit int32) ApiGetTxListDetailsRequest {
	r.eventLimit = &eventLimit
	return r
}

// Result offset
func (r ApiGetTxListDetailsRequest) EventOffset(eventOffset int32) ApiGetTxListDetailsRequest {
	r.eventOffset = &eventOffset
	return r
}

// Include data from unanchored (i.e. unconfirmed) microblocks
func (r ApiGetTxListDetailsRequest) Unanchored(unanchored bool) ApiGetTxListDetailsRequest {
	r.unanchored = &unanchored
	return r
}

func (r ApiGetTxListDetailsRequest) Execute() (*map[string]GetTxListDetails200ResponseValue, *http.Response, error) {
	return r.ApiService.GetTxListDetailsExecute(r)
}

/*
GetTxListDetails Get list of details for transactions

Retrieves a list of transactions for a given list of transaction IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTxListDetailsRequest
*/
func (a *TransactionsAPIService) GetTxListDetails(ctx context.Context) ApiGetTxListDetailsRequest {
	return ApiGetTxListDetailsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]GetTxListDetails200ResponseValue
func (a *TransactionsAPIService) GetTxListDetailsExecute(r ApiGetTxListDetailsRequest) (*map[string]GetTxListDetails200ResponseValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]GetTxListDetails200ResponseValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionsAPIService.GetTxListDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/extended/v1/tx/multiple"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.txId == nil {
		return localVarReturnValue, nil, reportError("txId is required and must be specified")
	}

	{
		t := *r.txId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tx_id", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tx_id", t, "form", "multi")
		}
	}
	if r.eventLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_limit", r.eventLimit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.eventLimit = &defaultValue
	}
	if r.eventOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event_offset", r.eventOffset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.eventOffset = &defaultValue
	}
	if r.unanchored != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unanchored", r.unanchored, "form", "")
	} else {
		var defaultValue bool = false
		r.unanchored = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
